import discord
from discord.ext import commands
import yt_dlp
from keep_alive import keep_alive
import os
import asyncio
import traceback  # ‡πÄ‡∏û‡∏¥‡πà‡∏° traceback ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏ß‡∏¢‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î

intents = discord.Intents.default()
intents.message_content = True
intents.voice_states = True
intents.guilds = True
intents.guild_messages = True

bot = commands.Bot(command_prefix='!', intents=intents)

# ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ yt-dlp
ydl_opts = {
    'format': 'bestaudio/best',
    'quiet': True,
    'no_warnings': True,
    'noplaylist': True,
    'extract_flat': True,  # ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏á
    'postprocessors': [{
        'key': 'FFmpegExtractAudio',
        'preferredcodec': 'mp3',
        'preferredquality': '192',
    }],
    'socket_timeout': 10,  # ‡πÄ‡∏û‡∏¥‡πà‡∏° timeout ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏≤‡∏á
}

# ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ FFMPEG
FFMPEG_OPTIONS = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5 -nostdin',
    'options': '-vn -sn -dn -loglevel warning'  # ‡πÄ‡∏û‡∏¥‡πà‡∏° loglevel warning ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
}

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á
class MusicPlayer:
    def __init__(self):
        self.queue = asyncio.Queue()
        self.current = None
        self.loop = asyncio.get_event_loop()
        self.next = asyncio.Event()
        self.np = None

    async def player_loop(self, ctx):
        while True:
            self.next.clear()
            try:
                async with asyncio.timeout(180):  # 3 ‡∏ô‡∏≤‡∏ó‡∏µ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏´‡∏°‡πà
                    self.current = await self.queue.get()
            except asyncio.TimeoutError:
                return await ctx.voice_client.disconnect()

            voice_client = ctx.voice_client
            if not voice_client:
                return

            try:
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = await bot.loop.run_in_executor(None, lambda: ydl.extract_info(self.current, download=False))
                    if 'entries' in info:
                        info = info['entries'][0]

                    format_selector = ydl.build_format_selector('bestaudio/best')
                    formats = list(format_selector({**info}))  # ‡πÅ‡∏õ‡∏•‡∏á generator ‡πÄ‡∏õ‡πá‡∏ô list
                    if not formats:
                        await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°")
                        continue

                    url = formats[0]['url']
                    title = info.get('title', 'Unknown')

                    source = discord.FFmpegPCMAudio(url, **FFMPEG_OPTIONS)
                    voice_client.play(source, after=lambda _: bot.loop.call_soon_threadsafe(self.next.set))

                    await ctx.send(f'‚ñ∂Ô∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á: **{title}**')

                    await self.next.wait()
                    try:
                        if source and source._process and source._process.poll() is None:
                            source.cleanup()
                    except Exception as cleanup_error:
                        print(f"Error during cleanup: {cleanup_error}")
                    self.current = None

            except Exception as e:
                await ctx.send(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á: {str(e)}")
                error_details = traceback.format_exc()  # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• traceback ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                print(f"Detailed error: {error_details}")  # ‡∏û‡∏¥‡∏°‡∏û‡πå traceback ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ã‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡πà‡∏ß‡∏¢‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
                continue

players = {}

@bot.event
async def on_ready():
    print(f'Bot ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß: {bot.user.name}')
    await bot.change_presence(activity=discord.Game(name="!commands"))

@bot.command()
async def play(ctx, *, url):  # ‡πÄ‡∏û‡∏¥‡πà‡∏° * ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö URL ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á
    if not ctx.author.voice:
        await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô!")
        return

    channel = ctx.author.voice.channel
    voice_client = ctx.voice_client

    try:
        if not voice_client:
            try:
                voice_client = await channel.connect(timeout=10.0)
                await ctx.send("üéµ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß")
            except asyncio.TimeoutError:
                await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÑ‡∏î‡πâ (timeout)")
                return
            except Exception as e:
                await ctx.send(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: {str(e)}")
                return

        if ctx.guild.id not in players:
            players[ctx.guild.id] = MusicPlayer()
            bot.loop.create_task(players[ctx.guild.id].player_loop(ctx))

        await players[ctx.guild.id].queue.put(url)
        await ctx.send("‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß‡πÅ‡∏•‡πâ‡∏ß")

    except Exception as e:
        await ctx.send(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}")
        if voice_client and voice_client.is_connected():
            await voice_client.disconnect()

@bot.command()
async def stop(ctx):
    voice_client = ctx.voice_client
    if voice_client and voice_client.is_playing():
        voice_client.stop()
        await ctx.send("‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß")
    else:
        await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà")

@bot.command()
async def leave(ctx):
    voice_client = ctx.voice_client
    if voice_client and voice_client.is_connected():
        if voice_client.is_playing():
            voice_client.stop()
        await voice_client.disconnect()
        if ctx.guild.id in players:
            del players[ctx.guild.id]
        await ctx.send("üëã ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß")
    else:
        await ctx.send("‚ùå ‡∏ö‡∏≠‡∏ó‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á")

@bot.command()
async def queue(ctx):
    if ctx.guild.id not in players:
        await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ")
        return

    player = players[ctx.guild.id]
    if player.queue.empty():
        await ctx.send("üìã ‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏•‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà")
        return

    queue_list = "üìã **‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß:**\n"
    queue_copy = player.queue._queue.copy()
    for i, url in enumerate(queue_copy, 1):
        queue_list += f"{i}. {url}\n"
    await ctx.send(queue_list)

@bot.command()
async def commands(ctx):
    commands_text = """
üìã **‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ:**
`!play [URL]` - ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏à‡∏≤‡∏Å YouTube URL
`!stop` - ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏•‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
`!queue` - ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß
`!leave` - ‡πÉ‡∏´‡πâ‡∏ö‡∏≠‡∏ó‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á
`!commands` - ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
    """
    await ctx.send(commands_text)

keep_alive()
bot.run(os.environ['TOKEN'])
